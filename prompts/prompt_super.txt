# 고도화된 프롬프팅 전략 (Gemini Advanced Prompting)

당신은 **시간표 최적화 전문 알고리즘 엔지니어**입니다.
복잡한 비즈니스 로직을 정확하고 효율적으로 구현하는 것이 당신의 전문 분야입니다.

## 미션 브리핑

대학생의 시간표를 분석하여 교내 알바가 가능한 시간을 찾는 알고리즘을 설계하고 구현해야 합니다.
이 문제는 **6가지 복합 제약 조건**을 모두 만족해야 하는 까다로운 최적화 문제입니다.

## 단계별 접근 방법

### Step 1: 문제 분석 (먼저 이것부터 작성해주세요)

다음 질문에 답하면서 문제를 분석하세요:
1. 입력 데이터에는 어떤 정보가 포함되어 있나요?
2. 출력 데이터는 어떤 형식이어야 하나요?
3. 6가지 제약 조건 중 가장 까다로운 것은 무엇인가요?
4. 어떤 엣지 케이스를 고려해야 하나요?

### Step 2: 알고리즘 설계 (의사코드 작성)

JavaScript 코드를 작성하기 전에, **의사코드**로 알고리즘을 설계하세요:
```
1. 요일별로 반복
2. 각 요일에 대해:
   a. 강의 시간을 시작 시간 기준으로 정렬
   b. 가능한 모든 공강 시간 찾기
   c. 각 공강 시간에 대해 6가지 규칙 검증
   d. 통과한 시간대 중 가장 긴 것 선택
3. 결과 반환
```

### Step 3: 핵심 로직 구현

특히 다음 두 가지 까다로운 로직에 집중하세요:

#### 로직 A: 인접 건물 이동 시간 계산
```
강의 종료 후 알바까지의 이동 시간을 계산할 때:
- 강의.location이 constraints.adjacentBuildings에 포함되는가?
  → YES: 이동 시간 = 5분
  → NO: 이동 시간 = constraints.travelTime (15분)
```

#### 로직 B: 최대 근무 시간 선택
```
같은 요일에 여러 가능한 시간대가 있을 때:
- 각 시간대의 길이 (end - start) 계산
- 가장 긴 시간대 선택
- 만약 같은 길이라면 먼저 시작하는 시간대 선택
```

## 상세 명세

### 입력 인터페이스
```javascript
schedule: Array<{
  day: "월" | "화" | "수" | "목" | "금",
  name: string,
  start: "HH:MM",
  end: "HH:MM",
  location: string  // 🔑 핵심: 이동 시간 계산에 사용
}>

constraints: {
  travelTime: number,              // 일반 이동 시간 (분)
  minWorkableSession: number,      // 최소 근무 시간 (분)
  campusHours: {
    start: "HH:MM",
    end: "HH:MM"
  },
  workLocation: string,
  adjacentBuildings: string[]      // 🔑 핵심: 5분 이동 가능한 건물들
}
```

### 출력 인터페이스
```javascript
Array<{
  day: string,
  start: "HH:MM",
  end: "HH:MM"
}>
```

## 6가지 제약 조건 (우선순위 순)

### ✅ Rule #1: 강의 시간 중첩 금지
- 알바 시간이 어떤 강의와도 겹치지 않아야 함
- 검증: `알바.start >= 강의.end || 알바.end <= 강의.start`

### ✅ Rule #2: 이동 시간 준수 ⭐️ (가장 까다로운 규칙)
- 강의 종료 → 알바 시작: 이동 시간 필요
- 알바 종료 → 다음 강의: 이동 시간 필요
- **중요**: 인접 건물이면 5분, 아니면 15분
```javascript
function getTravelTime(fromLocation, adjacentBuildings, defaultTime) {
  return adjacentBuildings.includes(fromLocation) ? 5 : defaultTime;
}
```

### ✅ Rule #3: 최소 근무 시간
- `(알바.end - 알바.start) >= minWorkableSession`

### ✅ Rule #4: 캠퍼스 활동 시간
- `알바.start >= campusHours.start`
- `알바.end <= campusHours.end`

### ✅ Rule #5: 완전성
- 가능한 모든 시간대를 탐색
- 놓치는 시간대가 없어야 함

### ✅ Rule #6: 최대 근무 시간 선택 ⭐️
- 같은 요일의 여러 시간대 중 가장 긴 것 선택
```javascript
const longestSlot = possibleSlots.reduce((max, slot) => {
  const duration = timeDiff(slot.end, slot.start);
  const maxDuration = timeDiff(max.end, max.start);
  return duration > maxDuration ? slot : max;
});
```

## 구현 체크리스트

구현 후 다음을 자체 검증하세요:

- [ ] 시간 문자열 파싱 함수 구현 ("HH:MM" → 분)
- [ ] 요일별 강의 분류 로직
- [ ] 인접 건물 체크 함수
- [ ] 이동 시간 계산 로직 (인접/일반 구분)
- [ ] 공강 시간 찾기 알고리즘
- [ ] 6가지 규칙 검증 로직
- [ ] 최대 근무 시간 선택 로직
- [ ] 엣지 케이스 처리 (하루 시작/끝, 연속 강의)

## 테스트 시나리오

### 시나리오 1: 인접 건물 효과
```
월요일:
- 09:00-10:30 알고리즘 (정보관) ← 인접 건물
- 13:00-15:00 데이터베이스 (공대)

예상 결과:
- 10:35-12:45 가능 (정보관 → 5분 이동, 공대 ← 15분 이동)
```

### 시나리오 2: 최대 시간 선택
```
화요일:
- 09:00-10:00 강의A
- 14:00-15:00 강의B

가능한 시간대:
1. 10:15-13:45 (210분)
2. 15:15-18:00 (165분)

선택: 1번 (더 길기 때문)
```

## 최종 요청

1. **먼저** 위의 Step 1, 2를 작성하여 문제를 분석하고 알고리즘을 설계하세요
2. **그 다음** JavaScript로 구현하세요
3. **마지막으로** 작성한 코드가 6가지 규칙을 모두 만족하는지 검증하고 설명하세요

특히 **Rule #2 (인접 건물)**와 **Rule #6 (최대 시간)**에 집중하세요.
이 두 가지가 이 문제의 핵심 난이도입니다.
