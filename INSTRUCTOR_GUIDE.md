# 🎓 GDG DevFest 핸즈온 - 운영자 가이드

## 📋 세션 개요

**세션명**: AI를 활용한 스마트 코딩 - 꿀알바 타임 찾기  
**소요 시간**: 60분  
**난이도**: 초급~중급  
**사전 준비**: Gemini CLI 설치, Node.js 18+ 설치

## 🎯 학습 목표

1. 프롬프트 엔지니어링의 기본 원칙 이해
2. Naive vs Smart 프롬프트의 차이 체험
3. AI를 활용한 실제 문제 해결 경험
4. 생성된 코드의 품질 평가 능력 향상

## ⏱️ 세션 타임라인 (60분)

### 1. 도입 및 환경 설정 (10분)
- [ ] 세션 목표 및 미션 소개
- [ ] 프로젝트 클론 및 의존성 설치
- [ ] 개발 서버 실행 확인

### 2. 문제 이해 및 데이터 탐색 (10분)
- [ ] `src/utils/data.js` 파일 설명
- [ ] 시간표 데이터 구조 분석
- [ ] 제약 조건 의미 설명
- [ ] UI에서 데이터 확인

### 3. 1단계: Naive 프롬프트 실습 (15분)
- [ ] `prompts/prompt_naive.txt` 내용 설명
- [ ] Gemini CLI로 코드 생성
- [ ] 생성된 코드를 `timeProcessor.js`에 적용
- [ ] 결과 확인 및 문제점 토론

**예상 문제점**:
- 제약 조건 미반영
- 이동 시간 미고려
- 최소 근무 시간 체크 누락
- 요일별 처리 미흡

### 4. 2단계: Smart 프롬프트 실습 (20분)
- [ ] `prompts/prompt_smart.txt` 내용 설명
- [ ] 역할 부여 및 대화형 프롬프트 강조
- [ ] Gemini CLI와 대화하며 코드 개선
- [ ] 개선된 코드 적용 및 결과 비교

**핵심 차이점 강조**:
- 역할(Role) 부여의 효과
- 맥락(Context) 제공의 중요성
- 대화형 접근의 장점
- 단계적 사고 유도

### 5. 결과 비교 및 토론 (5분)
- [ ] 두 접근 방식의 결과 차이 분석
- [ ] 프롬프트 품질이 코드 품질에 미치는 영향
- [ ] 실무 적용 방안 토론

## 🔧 트러블슈팅

### 문제 1: npm install 실패
**해결책**: Node.js 버전 확인 (18 이상 필요)
```bash
node --version
```

### 문제 2: Gemini CLI 인증 오류
**해결책**: API 키 재설정
```bash
gemini auth login
```

### 문제 3: 생성된 코드가 작동하지 않음
**해결책**: 
- 함수 시그니처 확인 (`schedule`, `constraints` 파라미터)
- 반환 형식 확인 (`[{ day, start, end }]`)
- 콘솔 에러 메시지 확인

### 문제 4: 시간 계산 로직 오류
**해결책**: 
- 시간 문자열 파싱 방법 힌트 제공
- `Date` 객체 또는 분 단위 변환 방법 안내

## 💡 참가자 지원 팁

### Level 1: 완전 초보자
- 기본 JavaScript 문법 간단히 설명
- 콘솔 로그로 디버깅하는 방법 안내
- 단계별 힌트 제공

### Level 2: 중급자
- 더 나은 프롬프트 작성 방법 제안
- 엣지 케이스 처리 방법 토론
- 코드 최적화 아이디어 공유

### Level 3: 고급자
- 추가 제약 조건 추가 도전
- 테스트 코드 작성 권장
- 다른 참가자 멘토링 역할

## 📊 평가 기준 (선택 사항)

### 기본 구현 (60점)
- [ ] 공강 시간 찾기 (20점)
- [ ] 이동 시간 고려 (20점)
- [ ] 최소 근무 시간 체크 (20점)

### 고급 구현 (30점)
- [ ] 요일별 정확한 처리 (10점)
- [ ] 캠퍼스 운영 시간 준수 (10점)
- [ ] 엣지 케이스 처리 (10점)

### 프롬프트 품질 (10점)
- [ ] 명확한 요구사항 전달 (5점)
- [ ] 제약 조건 정확히 명시 (5점)

## 🎁 참가자용 추가 도전 과제

### 도전 1: 더 많은 제약 조건 추가
- 점심 시간 제외
- 특정 요일 선호도 반영
- 연속 근무 시간 제한

### 도전 2: UI 개선
- 알바 가능 시간을 시간표에 시각화
- 필터링 기능 추가
- 제약 조건 동적 변경

### 도전 3: 프롬프트 최적화
- 한 번의 프롬프트로 완벽한 코드 생성
- 다양한 프롬프트 전략 실험
- 최적의 프롬프트 패턴 발견

## 📝 세션 종료 체크리스트

- [ ] 참가자들이 두 가지 프롬프트 차이를 이해했는가?
- [ ] 모든 참가자가 작동하는 코드를 완성했는가?
- [ ] 프롬프트 엔지니어링의 중요성을 체감했는가?
- [ ] GitHub Classroom 제출 방법을 안내했는가?
- [ ] Q&A 시간을 가졌는가?

## 🔗 추가 자료

- [Google AI Studio](https://makersuite.google.com/)
- [Prompt Engineering Guide](https://www.promptingguide.ai/)
- [Gemini API Documentation](https://ai.google.dev/docs)

---

**운영자 노트**: 
- 참가자들의 다양한 접근 방법을 격려하세요
- 정답은 하나가 아니며, 과정이 중요함을 강조하세요
- AI는 도구일 뿐, 최종 판단은 개발자가 한다는 점을 알려주세요
